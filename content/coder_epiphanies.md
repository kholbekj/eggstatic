# Coder's Epiphanies

I like Ruby. I have lots of little reasons why. Probably every programmer does, for their language of choice. Programmers will defend their language like there's no tomorrow.

I think part of the reason has to do with the associations created when you first go through certain parts of the programmer's journey. The very first stuff you do leaves an impression, but a mild, sometimes frustrating one. Sure you toss around a few variables, maybe buttons appear, maybe a command line asks your name and reads it back to you. Great. Why did I need to spend 2 hours installing Ubuntu for this?

Later, if you persist, you find yourself in the mode of "The computer is in charge, but if I wave my hands just right, I can make things happen!". This is a fun stage, but the language is still working against you, and the paradigms are still too foreign to create pure positive associations. The programming language is a hinderance between you and the thing you want to get done.

And then comes the first grand coder epiphany. At some point, you realize that with what you know, and enough APIs and SDKs, the world is yours. You can do _anything_. There is lightning sparking from your fingers. You don't know the _best_ way to do things, there are many things where you're unsure where you would begin, but once the building blocks of programming settles in, you know. You know that it's this stuff all the way up and down, and you can make the computer dance for you.

I think whatever language you happen to go through this with will always hold a special place.

At Stripe, I was the only programmer in my team who actually came from a Ruby background—Stripe didn't hire for that, they assumed (correctly) that good engineers can pick up Ruby. But I still remember my surprise when one of the engineers in my team— who'd been there for a while and worked entirely in Ruby—told me that when he needed to get anything DONE, he'd whip out NodeJS and build little prototypes and stuff. I was baffled. How could you command Sinatra and Rails, and still find it more pleasant to write a Node app? But there it was. He told me that was the stack he got started in programming with. 

There are other such moments, down the line. I'm not sure if any are quite as powerful, but I think some come close. The first time I tried TDD in Smalltalk was very powerful. I already knew and liked TDD, but the meaning was completely different in Smalltalk. If you don't know, go try it. And the first time I eval'd Elisp in the context of Emacs. These were instances of a feeling of unrivaled connectedness with the operating system underneath, and it felt wildly direct and powerful. No weird Unix'y indirection, just code running code running code, and my keyboard plugged straight into the middle of that cosmos.

Elixir sparked something too. This idea of spawning these little processes that have their own little mailbox and scheduling and can do their work in a supervision tree. This clear and very different model of organizing computation. Of course this was Erlang shining through, but without Elixir I'd have never found out.

Forth, as powerful as it is, just filled me to the brim with terror for the sheer unnaturalness of it all, and I hid before that abyss could stare back.

I think learning programming should be done with something more akin to the Smalltalk/Elisp experience. Something where you can build a wonderful and educative system, but the student can take your creation apart and make it their own. But the holy grail would be if such a system could be the very same that they'll go work on to get real work done later. Not something where that is _theoretically_ possible, but something where no-one would bat an eye if they would just continue working with it.

I can't wait for my next coder epiphany.
